{"posts":[{"title":"SQL Server触发器学习笔记","content":"触发器类型SQLServer中有两种类型的触发器：AFTER触发器和INSTEADOF触发器。AFTER触发器是在执行DML语句（INSERT、UPDATE或DELETE）后触发的，而INSTEADOF触发器是在执行DML语句之前触发的。如果使用INSTEADOF触发器，可以在执行DML语句之前修改或替换数据。触发器事件触发器可以在INSERT、UPDATE或DELETE语句执行之后自动执行。在定义触发器时，可以指定要监视的事件类型。例如，在定义触发器时，可以指定它应该在INSERT语句执行之后触发，如下所示：CREATETRIGGERtr_exampleONexample_tableAFTERINSERTASBEGIN--触发器主体END在这个例子中，触发器将在example_table表中执行INSERT语句之后触发。触发器主体触发器主体是触发器中实际执行的代码。可以在触发器主体中使用任何有效的T-SQL语句，包括INSERT、UPDATE、DELETE、SELECT以及条件和循环结构。在触发器主体中，可以使用两个特殊的表：inserted和deleted。这些表包含由DML语句插入、更新或删除的行的副本。插入的行存储在inserted表中，而删除的行存储在deleted表中。如果在UPDATE语句中修改了行，则旧行存储在deleted表中，而新行存储在inserted表中。下面是一个示例触发器，当在example_table表中执行INSERT语句时，它将向example_log表中插入一条日志记录：CREATETRIGGERtr_example_insertONexample_tableAFTERINSERTASBEGININSERTINTOexample_log(log_date,message)SELECTGETDATE(),'Newrowinsertedintoexample_table.'FROMinserted;END在这个触发器中，我们使用了inserted表来检索刚刚插入的行，并将日志记录插入到example_log表中。触发器的优点和缺点触发器的优点是它们可以自动执行某些操作，从而简化了应用程序中的代码。触发器还可以在数据库层面上实施业务规则，从而确保数据的完整性和一致性。触发器的缺点是它们可能会导致性能问题。如果触发器包含复杂的逻辑或在大型表上执行，可能会对数据库的性能产生负面影响。此外，触发器可能会使代码难以维护，因为它们在数据库层面上执行操作，而不是在应用程序代码中执行。总结SQLServer触发器是一种强大的工具，可以在表发生变化时自动执行一些操作。在定义触发器时，可以指定要监视的事件类型和触发器主体中要执行的代码。触发器的优点是可以自动执行操作和实施业务规则，但它们可能会导致性能问题和代码维护难度。","link":"https://Famousgavin.github.io/test/"},{"title":"【Windows】➥ Clash for Windows【推荐】✔️","content":"🚫注意事项💡已经证实360/毒霸/2345等全家桶(包含安全卫士及杀毒)会拦截此软件导致无法使用，需要卸载后重启再试。如担心系统安全可以安装火绒安全软件💡如果电脑里安装过其他代理软件可能会产生冲突导致无法正常运行，包括谷歌、EDGE浏览器的第三方代理插件（例：谷歌访问助手）需要卸载后才能正常使用。💡使用Windows宽带拨号上网时会无法使用本软件，需要切换到通过路由器或者WIFI上网。💡如果服务器全部显示timeout（超时）大概率是系统时间和北京时间有误差（大于2分钟），检查一下，最好同步一下系统时间。1.获取应用软件版本更新较快，如果追新请点击进入【官方Releases-英文版】页面下载。下载解压后安装至磁盘运行ClashforWindows。⚠️（不建议安装至系统盘（C盘），安装至系统盘（C盘）可能会出现权限问题。⚠️（由于软件需要更改系统的代理设置，权限比较敏感，第一次运行程序时请右键，选择【以管理员身份运行】百度网盘：下载软件-中文版提取码：4tqy2.快速导入此处我们将指导您使用「一键导入」方式完成配置。注意：如果「**导入到Clash&amp;&amp;」失败，也可以手动添加订阅。步骤：点击网站仪表盘的【一键订阅】&gt;【复制订阅地址】复制，打开App，然后点击【**Profiles**】&gt;点击地址栏后面的【粘贴】图标，点击【Download】。分组名称：www.bohe7.comUrl（你的订阅地址）：https://v2.bohe7.icu/api/v1/client/subscribe?token=9f7fbc0ddcddf07aae5f5f83a4f6c3da3.开始连接返回到初始界面General，并且打开系统连接！SystemProxy即为代理开关如果SystemProxy开关已经打开，此时已经可以使用本站提供的服务了。4.软件简介功能说明General-系统配置及开关页面Proxies-节点线路Profiles-订阅管理代理模式Global-全局模式，所有数据都会通过代理连接Rule-规则模式，自动判断数据是否需要通过代理连接⚠️日常使用时请保持【Rule】模式，否则可能会影响使用。Driect-直连模式，相当于关闭代理Script-脚本模式5.关于TUN模式的说明什么是TUN模式？对于不遵循系统代理的软件（软件是不加载系统代理的），开启TUN模式后，CFW会加载虚拟网卡至系统，TUN模式可以接管其流量并交由CFW处理，在Windows中，TUN模式性能比TAP模式好；比较适用于各种安卓模拟器（用来玩外服游戏）以及Telegram等需要代理的软件，如果你不需要这个功能则不用开启TUN模式。1.点击【General】找到【ServiceMode】，点击后面的【Manage】2.在弹出的窗口中点击【Install】安装，点击安装后可能没什么反应，稍等片刻退出软件重新打开就可以了。3.安装成功后，【ServiceMode】旁边的地球标识会变为绿色，这时再开启TUNMode就可以了。提示：近期大部分浏览器默认已经开启“安全DNS”功能，此功能会影响TUN模式劫持DNS请求导致反推域名失败，请在浏览器设置中关闭此功能以保证TUN模式正常运行；如果你不知道怎么操作，关闭TUN模式就可以了。","link":"https://Famousgavin.github.io/clashforwin/"},{"title":"SQLServer 日期查询","content":"SQLServer日期函数大全统计语句统计当前【&gt;当天00点以后的数据】SELECT*FROM表WHERECONVERT(Nvarchar,dateandtime,111)=CONVERT(Nvarchar,GETDATE(),111)ORDERBYdateandtimeDESC统计本周SELECT*FROM表WHEREdatediff(week,[dateadd],getdate())=0统计本月SELECT*FROM表WHEREdatediff(month,[dateadd],getdate())=0统计当前SELECT*FROM表WHEREdatediff(day,[dateadd],getdate())=0Select*Fromtablewith(nolock)WhereConvert(varchar(10),[CreateTime],120)=Convert(varchar(10),getDate(),120)时间函数当前系统日期、时间selectgetdate()dateadd在向指定日期加上一段时间的基础上，返回新的datetime值，例如：向日期加上2天selectdateadd(day,2,'2004-10-15')--返回：2004-10-1700:00:00.000datediff返回跨两个指定日期的日期和时间边界数selectdatediff(day,'2004-09-01','2004-09-18')--返回：17datepart返回代表指定日期的指定日期部分的整数SELECTDATEPART(month,'2004-10-15')--返回10datename返回代表指定日期的指定日期部分的字符串SELECTdatename(weekday,'2004-10-15')--返回：星期五day(),month(),year()--可以与datepart对照一下select当前日期=convert(varchar(10),getdate(),120)select当前时间=convert(varchar(8),getdate(),114)selectdatename(dw,'2004-10-15')select本年第多少周=datename(week,'2004-10-15')select今天是周几=datename(weekday,'2004-10-15')求相差天数selectdatediff(day,'2004-01-01',getdate())一个月第一天的SELECTDATEADD(mm,DATEDIFF(mm,0,getdate()),0)本周的星期一SELECTDATEADD(wk,DATEDIFF(wk,0,getdate()),0)selectdateadd(wk,datediff(wk,0,getdate()),6)一年的第一天SELECTDATEADD(yy,DATEDIFF(yy,0,getdate()),0)季度的第一天SELECTDATEADD(qq,DATEDIFF(qq,0,getdate()),0)当天的半夜SELECTDATEADD(dd,DATEDIFF(dd,0,getdate()),0)上个月的最后一天SELECTdateadd(ms,-3,DATEADD(mm,DATEDIFF(mm,0,getdate()),0))去年的最后一天SELECTdateadd(ms,-3,DATEADD(yy,DATEDIFF(yy,0,getdate()),0))本月的最后一天SELECTdateadd(ms,-3,DATEADD(mm,DATEDIFF(m,0,getdate())+1,0))本年的最后一天SELECTdateadd(ms,-3,DATEADD(yy,DATEDIFF(yy,0,getdate())+1,0))本月的第一个星期一selectDATEADD(wk,DATEDIFF(wk,0,dateadd(dd,6-datepart(day,getdate()),getdate())),0)查询本周注册人数selectcount(*)from[user]wheredatediff(week,create_day-1,getdate())=0上周注册人数selectcount(*)from[user]wheredatediff(week,create_day-1,getdate())=1本月注册人数selectcount(*)from[user]wheredatediff(month,create_day,getdate())=0上月注册人数selectcount(*)from[user]wheredatediff(month,create_day,getdate())=1如果要效率，用一下方式查询本周注册人数selectcount(*)from[user]wherecreate_day&gt;=dateadd(day,2-datepart(weekday,getdate()),convert(varchar,getdate(),112))andcreate_day&lt;dateadd(day,9-datepart(weekday,getdate()),convert(varchar,getdate(),112))上周注册人数selectcount(*)from[user]wherecreate_day&gt;=dateadd(day,-5-datepart(weekday,getdate()),convert(varchar,getdate(),112))andcreate_day&lt;dateadd(day,2-datepart(weekday,getdate()),convert(varchar,getdate(),112))本月注册人数selectcount(*)from[user]wherecreate_day&gt;=dateadd(day,1-day(getdate()),convert(varchar,getdate(),112))andcreate_day&lt;dateadd(month,1,dateadd(day,1-day(getdate()),convert(varchar,getdate(),112)))上月注册人数selectcount(*)from[user]wherecreate_day&gt;=dateadd(month,-1,dateadd(day,1-day(getdate()),convert(varchar,getdate(),112)))andcreate_day&lt;dateadd(day,1-day(getdate()),convert(varchar,getdate(),112))本周selectcount(*)fromUserwheredatediff(dd,create_day,getdate())&lt;=datepart(dw,getdate())上周selectcount(*)fromUserwheredatediff(dd,create_day,(getdate()-datepart(dw,getdate())))&lt;=7本月selectcount(*)fromUserwheredatepart(mm,create_day)=datepart(mm,getdate())上月selectcount(*)fromUserwheredatepart(mm,create_day)=datepart(mm,getdate())-1本周注册人数selectcount(*)from[User]wheredatediff(dd,create_day,getdate())&lt;=datepart(dw,getdate())上周注册人数selectcount(*)from[User]wheredatediff(dd,create_day,(getdate()-datepart(dw,getdate())))&lt;=7本月注册人数selectcount(*)from[User]wheredatepart(mm,create_day)=datepart(mm,getdate())上月注册人数selectcount(*)from[User]wheredatepart(mm,create_day)=datepart(mm,getdate())-1查询今日所有SELECT*fromfeedbackWHERE(DATEDIFF(d,fedtime,GETDATE())=0)ORDERBYfedidDESCmonth(create_day)=month(getdate())本月month(create_day)=month(getdate())-1上月今天的所有数据：select*from表名whereDateDiff(dd,datetime类型字段，getdate())=0昨天的所有数据：select*from表名whereDateDiff(dd,datetime类型字段，getdate())=17天内的所有数据：select*from表名whereDateDiff(dd,datetime类型字段，getdate())&lt;=730天内的所有数据：select*from表名whereDateDiff(dd,datetime类型字段，getdate())&lt;=30本月的所有数据：select*from表名whereDateDiff(mm,datetime类型字段，getdate())=0本年的所有数据：select*from表名whereDateDiff(yy,datetime类型字段，getdate())=0系统函数系统函数函数参数/功能getDate()返回系统目前的日期与时间DateDiff(interval,date1,date2)以interval指定的方式，返回date2与date1两个日期之间的差值date2-date1DateAdd(interval,number,date)以interval指定的方式，加上number之后的日期DatePart(interval,date)返回日期date中，interval指定部分所对应的整数值DateName(interval,date)返回日期date中，interval指定部分所对应的字符串名称参数interval的设定值值缩写（SqlServer）Access和ASP说明YearYyyyyy年QuarterQqq季MonthMmm月DayofyearDyy一年的日数，一年中的第几日DayDdd日WeekdayDww一周的日数，一周中的第几日WeekWkww周，一年中的第几周HourHhh时MinuteMin分钟SecondSss秒MillisecondMs-毫秒access和asp中用date()和now()取得系统日期时间；其中DateDiff,DateAdd,DatePart也同是能用于Access和asp中，这些函数的用法也类似","link":"https://Famousgavin.github.io/sqlserver_date/"},{"title":"CAGradientLayer的应用-渐变进度条","content":"分享是一种美德。座右铭：以前总以为坚持会让我们强大。✍️开始很久没写博客了，只要一停下来就很难在坚持，是要好好总结下最近工作内容，分享给大家。正在往大神方向一步一步走着。。。先看看效果：其实很简单，要用到UIView的CALayer,CAGradientLayer是CALayer的一个子类.我们将是使用CAGradientLayer的一些属性：colors,startPoint,endPoint，mask说道startPoint和endPoint我们必须明白iOS系统中CALayer的坐标系统：先创建UIView的一个子类GradualProgressView，并且重写-(instancetype)initWithFrame:(CGRect)frame:方法。在初始化方法中创建对象并且确认坐标系，坐标系不同的值有不同的效果，自己可以尝试下：CAGradientLayer*layer=(CAGradientLayer*)[selflayer];[layersetStartPoint:CGPointMake(0.0,0.5)];[layersetEndPoint:CGPointMake(1.0,0.5)];然后创建颜色渐变的UIColor对象并且用数组保存起来赋值给CAGradientLayer的colors属性：NSMutableArray*colorsArray=[NSMutableArrayarray];for(NSIntegeri=0;i&lt;=360;i+=5){UIColor*color=[UIColorcolorWithHue:1.0*i/360saturation:1.0brightness:1.0alpha:1.0];[colorsArrayaddObject:(id)[colorCGColor]];}[layersetColors:[NSArrayarrayWithArray:colorsArray]];现在运行的效果是：现在要添加一个移动的动画，我们可以获取CAGradientLayer的colors属性改变数组里面的顺序，并添加上动画：CAGradientLayer*layer=(CAGradientLayer*)[selflayer];NSMutableArray*colorArray=[[layercolors]mutableCopy];UIColor*lastColor=[colorArraylastObject];[colorArrayremoveLastObject];[colorArrayinsertObject:lastColoratIndex:0];NSArray*shiftedColors=[NSArrayarrayWithArray:colorArray];[layersetColors:shiftedColors];CABasicAnimation*animation=[CABasicAnimationanimationWithKeyPath:@&quot;gavin_colors&quot;];[animationsetToValue:shiftedColors];[animationsetDuration:0.08];[animationsetFillMode:kCAFillModeForwards];[animationsetDelegate:self];[layeraddAnimation:animationforKey:@&quot;gavin_animateGradient&quot;];为了移动动画可以一直持续，我们要设置动画的代理，并实现动画结束的代理方法，并在结束方法中在重复执行上面的动作。就实现了持续移动的动画。动画结束的代理方法：-(void)animationDidStop:(CAAnimation*)animationfinished:(BOOL)flag并在初始化方法中触发动画的开始。为了实现进度，我们需要增加二个属性，maskLayer用来遮挡和progress留给用户设置当前进度：/**Progressvaluesgofrom0.0to1.0*/@property(nonatomic,assign)CGFloatprogress;/**遮挡层*/@property(nonatomic,strong)CALayer*maskLayer;初始化遮挡层并利用CAGradientLayer的mask属性实现遮挡：self.maskLayer=[CALayerlayer];[self.maskLayersetFrame:CGRectMake(0.0,0.0,0.0,frame.size.height)];[self.maskLayersetBackgroundColor:[[UIColorblackColor]CGColor]];[layersetMask:self.maskLayer];当用户修改progress属性的值时我们要做相对应的改变，代码如下：-(void)setProgress:(CGFloat)value{if(_progress!=value){_progress=MIN(1.0,fabs(value));[selfsetNeedsLayout];}}-(void)layoutSubviews{CGRectmaskRect=[self.maskLayerframe];maskRect.size.width=CGRectGetWidth(self.bounds)*self.progress;[self.maskLayersetFrame:maskRect];}🌛结束这样就基本完成了，我们只需要创建GradualProgressView对象，就实现颜色渐变的进度条了。有什么不对的地方多多指教。希望大家多多关注我Git。最后附上具体的项目：ColorGradualProgress","link":"https://Famousgavin.github.io/gradient_layer/"},{"title":"Swift自定义运算符","content":"自定义运算符标准的运算符不够玩，那你可以声明一些个性的运算符，但个性的运算符只能使用这些字符/=-+*%&lt;&gt;！&amp;|^。~。新的运算符声明需在全局域使用operator关键字声明，可以声明为前置，中置或后置的。operatorprefix+++{}这段代码定义了一个新的前置运算符叫+++，此前Swift并不存在这个运算符。此处为了演示，我们让+++对Vector2D对象的操作定义为双自增这样一个独有的操作，这个操作使用了之前定义的加赋运算实现了自已加上自己然后返回的运算。@prefix@assignmentfunc+++(inoutvector:Vector2D)-&gt;Vector2D{vector+=vectorreturnvector}Vector2D的+++的实现和++的实现很接近,唯一不同的前者是加自己,后者是加值为(1.0,1.0)的向量.vartoBeDoubled=Vector2D(x:1.0,y:4.0)letafterDoubling=+++toBeDoubled//toBeDoubled现在是(2.0,8.0)//afterDoubling现在也是(2.0,8.0)自定义中置运算符的优先级和结合性可以为自定义的中置运算符指定优先级和结合性。可以回头看看优先级和结合性解释这两个因素是如何影响多种中置运算符混合的表达式的计算的。结合性(associativity)的值可取的值有left，right和none。左结合运算符跟其他优先级相同的左结合运算符写在一起时，会跟左边的操作数结合。同理，右结合运算符会跟右边的操作数结合。而非结合运算符不能跟其他相同优先级的运算符写在一起。结合性(associativity)的值默认为none，优先级(precedence)默认为100。以下例子定义了一个新的中置符+-，是左结合的left，优先级为140。operatorinfix+-{associativityleftprecedence140}func+-(left:Vector2D,right:Vector2D)-&gt;Vector2D{returnVector2D(x:left.x+right.x,y:left.y-right.y)}letfirstVector=Vector2D(x:1.0,y:2.0)letsecondVector=Vector2D(x:3.0,y:4.0)letplusMinusVector=firstVector+-secondVector//plusMinusVector此时的值为(4.0,-2.0)这个运算符把两个向量的x相加，把向量的y相减。因为他实际是属于加减运算，所以让它保持了和加法一样的结合性和优先级(left和140)。","link":"https://Famousgavin.github.io/swift-operator/"},{"title":"软件设计的不同模型：瀑布式、快速原型法以及迭代式","content":"我就软件设计开发过程中必须要完成的工作进行梳理，而我们需要注意到，这些需要完成的工作，在不同的开发流程模型的指导下可能有不同的时间要求，而我们需要关注的是在这个阶段内需要完成的工作，以及这个阶段内我们需要沟通的人员。需求分析需求分析是我们进行任何一个软件项目设计开发过程中都必须要完成的工作。这个工作通常与客户一起完成。在不同的项目中，这个“客户”可能来自真正的购买产品的用户，使用系统的用户，也有可能来自团队的某个人员，如产品经理等。软件设计开发团队的参与成员根据项目的不同规模，则参与的人员也有所不同。原则上，设计开发人员参与的时间点越早，对于需求的理解和把握会更好。这个阶段，通常需要软件架构师参与其中。从资源优化的角度来说，开发人员不必参与需求分析，但需要理解需求。需求分析的结果通常我们需要使用需求说明文档来描述，目前主流的需求描述方法包括：用户例图、用户故事等方式。这些方式有所不同的侧重，其核心思想就是描述清楚用户的使用场景。但无论采取何种方式，进行需求的描述，需求说明需要明确以下几点：所需要开发的软件系统边界；项目所有的相关及使用人员角色；项目关键的使用场景；项目规模、性能要求以及部署方式等非功能性需求。功能设计功能设计与需求分析差不多同时在开展，在很多软件项目中，对于功能设计不是特别重视。但对于某些软件项目而言，这是一个相当重要的工作。对于主要是用户界面的软件项目来说，功能设计可以看作是画出原型界面，描述使用场景，获得用户认可的过程。而对于没有界面的软件项目来说，则功能设计与需求分析的区分更为模糊。参与的人员与需求分析的参与人员类似，架构师更侧重于参与此类工作，并给与一些实现层面的判断和取舍。功能设计需要明确的核心是：项目的行为项目架构设计项目架构设计是一个非常依赖于经验的设计过程。需要根据软件项目的特定功能需求和非功能性需求进行取舍，最终获得一个满足各方要求的项目架构。项目架构的不同，将很大程度上决定项目开发和维护是否能够较为容易的适应需求变化，以及适应业务规模扩张。架构设计工作中，用户参与程度很低。软件开发团队中的需求人员参与程度也很低，但团队中的所有核心设计和开发人员都应该参与其中，并达成一致意见。架构设计的主要成果，是将项目的不同视图予以呈现，并使之落实到开发中：项目开发视图及技术路线选择；项目逻辑视图；项目部署视图；项目模块视图。在软件开发过程中，项目的架构不是一成不变的，随着设计人员和开发人员对于项目的理解不断深入，项目的架构也会发生演化。在软件项目中，架构设计是开发团队沟通的统一语言，设计文档必须要随着项目的变化进行更新，保障开发团队对于项目的理解和沟通的一致性。模块/子项目概要设计模块/子项目的概要设计，由架构师参与，核心设计和开发人员负责的方式进行。在概要设计工作中，我们需要在架构确定的开发路线的指导下，完成模块功能实现的关键设计工作。在概要设计阶段，需要关注于模块的核心功能和难点进行设计。这个过程中更多推荐的采用UML来进行概要设计，需要进行：模块实现机制设计、模块接口设计、关键类设计、画出时序图、交互图等。模块详细设计在瀑布式开发模型中，模块的详细设计会要求比较严格，将所有类进行详细设计。据我所知，除了一些对于项目健壮性要求非常严格的软件项目，如国防项目，金融项目还要求有详细设计文档之外。其他的项目大多采用其他方式来处理这样的工作，如自动化测试等。综上所述，软件设计文档作为软件开发团队的沟通、理解、知识共享的手段，具有非常重要的意义。而根据软件团队的规模，对于文档上承载的信息详细程度可以有不同程度的要求。我们软件团队对于如何使用设计文档有一个统一的理解，并坚持更新设计文档，这就是软件设计的最佳实践！自从1968年提出“软件工程”概念以来，软件开发领域对于借鉴传统工程的原则、方法，以提高质量、降低成本的探索就从未停止过。而在这个过程中，提出了许多不同的软件开发模型，典型的有：瀑布式，快速原型法，以及迭代式开发等。瀑布式模型是由W.W.Royce在1970年最初提出的软件开发模型，在瀑布模型中，开发被认为是按照需求分析，设计，实现，测试(确认)，集成，和维护顺序的进行。快速原型法快速原型模型的第一步是建造一个快速原型，实现客户或未来的用户与系统的交互，用户或客户对原型进行评价，进一步细化待开发软件的需求。通过逐步调整原型使其满足客户的要求，开发人员可以确定客户的真正需求是什么；第二步则在第一步的基础上开发客户满意的软件产品。迭代式开发在迭代式开发方法中，整个开发工作被组织为一系列的短小的、固定长度（如3周）的小项目，被称为一系列的迭代。每一次迭代都包括了需求分析、设计、实现与测试。采用这种方法，开发工作可以在需求被完整地确定之前启动，并在一次迭代中完成系统的一部分功能或业务逻辑的开发工作。再通过客户的反馈来细化需求，并开始新一轮的迭代。不同的开发模型，对于设计阶段的工作要求也不尽相同。相对来说，瀑布式模型中对于设计文档的力度要求得最细，而快速原型法对于设计的要求一般来说比较弱，迭代式开发在每一阶段中的设计文档工作量都相对较少，但在软件开发完成后，最终的设计文档完善程度要比快速原型法的好。软件设计的总体思路软件设计的本质就是针对软件的需求，建立模型，通过将模型映射为软件，来解决实际问题。因此软件设计需要解决的核心问题是建立合适的模型，使得能够开发出满足用户需求的软件产品，并具有以下特性：灵活性（Flexibility）、有效性（Efficiency）、可靠性（Reliability）、可理解性（Understandability）、维护性（Maintainability）、重用性（Reuse-ability）、适应性（Adaptability）、可移植性（Portability）、可追踪性（Traceability）、互操作性（Interoperability）。因此，软件设计并没有一套放之四海而皆准的方法和模板，需要我们的设计开发人员在软件的设计开发过程中针对软件项目的特点进行沟通和协调，整理出对软件项目团队的行之有效的方式，进行软件的设计。并保障软件设计文档的一致性，完整性和可理解性。谁来进行软件设计？在我们开发人员中，有很多人这样理解：“软件设计文档就是软件架构师和、项目经理、设计人员的事情”，其实不然。设计文档是整个软件开发团队的产出，其中有些设计文档由架构师、项目经理或者设计人员给出，有些文档由开发人员给出。这并没有一定的区分。最佳实践我们经常听到这样的话：“设计文档没有用，是用来糊弄客户和管理层的文档”；“用来写设计文档的时间，我的开发早就做完了”；“项目紧张，没有时间做设计”；这些言论，并不是正确的观念，根据软件项目的实际情况，软件开发设计团队可以约定设计文档的详细程度。项目团队需要保障设计文档的完整性和一致性，在项目进度紧张的情况下，软件设计文档可以更初略一些；在项目时间充裕的情况下，相关文档可以更为详尽。但是在项目开发过程中，需要软件设计开发团队对于设计文档有共同的理解。设计文档分类与使用通常来说，作为软件项目，我们需要有这几类文档:需求说明文档、功能设计文档、项目架构说明书、模块概要设计文档、模块详细设计文档。就像我之前说到的，在某个软件团队，对于以上的文档的要求是可以完全不同的，在简单项目中，可能所有类型的文档放在一个文档中进行说明；在复杂项目中，每一类文档可能都要写几个文档；而在最极端的情况下，可能每一类文档都能装订成几册。因此，在我们软件设计和开发人员心目中需要明确的是：文档并不是我们进行设计的目标，也不是我们设计过程中额外的工作。软件设计文档是我们在软件设计开发过程中形成的，用来在软件设计开发团队内部以及与各干系人之间进行沟通的文档，这些文档记录了软件项目中的各种知识，方案的思路、以及各种决策意见。下面我们就软件设计开发过程中必须要完成的工作进行梳理，而我们需要注意到，这些需要完成的工作，在不同的开发流程模型的指导下可能有不同的时间要求，而我们需要关注的是在这个阶段内需要完成的工作，以及这个阶段内我们需要沟通的人员。需求分析需求分析是我们进行任何一个软件项目设计开发过程中都必须要完成的工作。这个工作通常与客户一起完成。在不同的项目中，这个“客户”可能来自真正的购买产品的用户，使用系统的用户，也有可能来自团队的某个人员，如产品经理等。软件设计开发团队的参与成员根据项目的不同规模，则参与的人员也有所不同。原则上，设计开发人员参与的时间点越早，对于需求的理解和把握会更好。这个阶段，通常需要软件架构师参与其中。从资源优化的角度来说，开发人员不必参与需求分析，但需要理解需求。需求分析的结果通常我们需要使用需求说明文档来描述，目前主流的需求描述方法包括：用户例图、用户故事等方式。这些方式有所不同的侧重，其核心思想就是描述清楚用户的使用场景。但无论采取何种方式，进行需求的描述，需求说明需要明确以下几点：所需要开发的软件系统边界；项目所有的相关及使用人员角色；项目关键的使用场景；项目规模、性能要求以及部署方式等非功能性需求。功能设计功能设计与需求分析差不多同时在开展，在很多软件项目中，对于功能设计不是特别重视。但对于某些软件项目而言，这是一个相当重要的工作。对于主要是用户界面的软件项目来说，功能设计可以看作是画出原型界面，描述使用场景，获得用户认可的过程。而对于没有界面的软件项目来说，则功能设计与需求分析的区分更为模糊。参与的人员与需求分析的参与人员类似，架构师更侧重于参与此类工作，并给与一些实现层面的判断和取舍。功能设计需要明确的核心是：项目的行为项目架构设计项目架构设计是一个非常依赖于经验的设计过程。需要根据软件项目的特定功能需求和非功能性需求进行取舍，最终获得一个满足各方要求的项目架构。项目架构的不同，将很大程度上决定项目开发和维护是否能够较为容易的适应需求变化，以及适应业务规模扩张。架构设计工作中，用户参与程度很低。软件开发团队中的需求人员参与程度也很低，但团队中的所有核心设计和开发人员都应该参与其中，并达成一致意见。架构设计的主要成果，是将项目的不同视图予以呈现，并使之落实到开发中：项目开发视图及技术路线选择；项目逻辑视图；项目部署视图；项目模块视图。在软件开发过程中，项目的架构不是一成不变的，随着设计人员和开发人员对于项目的理解不断深入，项目的架构也会发生演化。在软件项目中，架构设计是开发团队沟通的统一语言，设计文档必须要随着项目的变化进行更新，保障开发团队对于项目的理解和沟通的一致性。模块/子项目概要设计模块/子项目的概要设计，由架构师参与，核心设计和开发人员负责的方式进行。在概要设计工作中，我们需要在架构确定的开发路线的指导下，完成模块功能实现的关键设计工作。在概要设计阶段，需要关注于模块的核心功能和难点进行设计。这个过程中更多推荐的采用UML来进行概要设计，需要进行：模块实现机制设计、模块接口设计、关键类设计、画出时序图、交互图等。模块详细设计在瀑布式开发模型中，模块的详细设计会要求比较严格，将所有类进行详细设计。据我所知，除了一些对于项目健壮性要求非常严格的软件项目，如国防项目，金融项目还要求有详细设计文档之外。其他的项目大多采用其他方式来处理这样的工作，如自动化测试等。综上所述，软件设计文档作为软件开发团队的沟通、理解、知识共享的手段，具有非常重要的意义。而根据软件团队的规模，对于文档上承载的信息详细程度可以有不同程度的要求。我们软件团队对于如何使用设计文档有一个统一的理解，并坚持更新设计文档，这就是软件设计的最佳实践！","link":"https://Famousgavin.github.io/pm-software-pattern/"}]}